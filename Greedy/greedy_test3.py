# <문제>1이 될 때까지
# 어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 합니다. 단, 두 번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있습니다.
# 1. N에서 1을 뺍니다.
# 2. N을 K로 나눕니다.
# N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하세요.

# 입력 : 25 5    출력 : 2

# my code
n, k = map(int,input().split())
cnt = 0

while (n>1):
    if (n % k == 0):
        n = n // k
        cnt = cnt +1
    else:
        n = n - 1
        cnt = cnt +1

print(cnt)

# 위의 코드는 매번 N을 확인한 후 연산 진행함. 해당 문제에서는 최대입력 수가 작으므로 괜찮음!
# 단, 몇 억까지 입력이 될 경우에, 시간복잡도가 log로 나오게 하려면 technique 필요. 
# 개인적으로 다음 코드보고 WoW했음..

while True:
    target = (n//k) * k # k로 나눌 수 있는 상태로 만들어주고 
    cnt += (n - target) # 그 상태가 n과 차이가 있다면 그만큼 1을 빼주는 cnt를 센다.
    n = target # 이제 (1을 빼준) 나눌 수 있는 상태인 값으로 n 변경

    # N이 K보다 작을 때(나눌 수 없을 때)는 while문 종료.
    if n<k:
        break
        
    # N이 K의 배수가 되었을 때 K로 나눈다.
    cnt = cnt +1
    n = n // k # n을 k로 나눔

# while문 탈출한 후 n이 1이 되도록 1번 연산 수행
result += (n-1)
print(result)
